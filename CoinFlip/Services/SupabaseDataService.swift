//
//  SupabaseDataService.swift
//  CoinFlip
//
//  Created on Sprint 11, Task 11.3
//  Real implementation of DataServiceProtocol using Supabase
//

import Foundation
import Supabase

/// Supabase data service for production
///
/// This service implements DataServiceProtocol using Supabase as the backend.
/// All operations are async and interact with the PostgreSQL database.
@MainActor
class SupabaseDataService: DataServiceProtocol {

    // MARK: - Shared Instance

    static let shared = SupabaseDataService()

    // MARK: - Properties

    private let supabase: SupabaseClient

    // MARK: - Initialization

    init() {
        self.supabase = SupabaseService.shared.client
    }

    init(supabase: SupabaseClient) {
        self.supabase = supabase
    }

    // MARK: - User Operations

    func fetchUser() async throws -> User? {
        // Check if offline
        if !NetworkMonitor.shared.isConnected {
            print("   üìµ Offline - cannot fetch user from database")
            throw DataServiceError.networkError(NSError(domain: "NetworkMonitor", code: -1009, userInfo: [
                NSLocalizedDescriptionKey: "No internet connection. Please check your network settings."
            ]))
        }

        // Get current auth user
        guard let authUser = try? await supabase.auth.session.user else {
            throw DataServiceError.notAuthenticated
        }

        // Fetch user from database
        let response = try await supabase
            .from("users")
            .select()
            .eq("auth_user_id", value: authUser.id.uuidString)
            .single()
            .execute()

        let decoder = JSONDecoder()
        // Don't use convertFromSnakeCase - User model has explicit CodingKeys
        decoder.dateDecodingStrategy = .iso8601

        let user = try decoder.decode(User.self, from: response.data)
        return user
    }

    func createUser(_ user: User) async throws -> User {
        // Create a dictionary with only the fields we should send
        // Don't send id, created_at, updated_at - these are auto-generated by the database
        var userDict: [String: Any] = [
            "username": user.username,
            "avatar_emoji": user.avatarEmoji,
            "starting_balance": user.startingBalance,
            "highest_net_worth": user.highestNetWorth,
            "current_streak": user.currentStreak,
            "best_streak": user.bestStreak
        ]

        // Add auth_user_id if present (use lowercase for PostgreSQL compatibility)
        if let authUserId = user.authUserId {
            userDict["auth_user_id"] = authUserId.uuidString.lowercased()
        }

        // Supabase insert expects an array of objects, not a single object
        let userArray = [userDict]
        let userData = try JSONSerialization.data(withJSONObject: userArray)

        // Debug: Print what we're sending
        if let jsonString = String(data: userData, encoding: .utf8) {
            print("üì§ Sending user data to Supabase (as array): \(jsonString)")
        }

        do {
            // First, verify we have an authenticated session
            print("üîç Checking auth session...")
            do {
                let session = try await supabase.auth.session
                print("‚úÖ Auth session found:")
                print("   - User ID: \(session.user.id)")
                print("   - Access token exists: \(session.accessToken.count > 0)")
                print("   - Token type: \(session.tokenType)")
            } catch {
                print("‚ùå No auth session! Error: \(error)")
                throw DataServiceError.notAuthenticated
            }

            print("üîç Attempting INSERT to Supabase...")
            print("üìä Request details:")
            print("   - Table: users")
            print("   - Method: INSERT (HTTP POST)")
            print("   - JSON size: \(userData.count) bytes")

            // Try raw HTTP request to see actual response
            let session = try await supabase.auth.session
            let supabaseURL = EnvironmentConfig.supabaseURL
            let url = URL(string: "\(supabaseURL)/rest/v1/users")!

            var request = URLRequest(url: url)
            request.httpMethod = "POST"
            request.setValue("application/json", forHTTPHeaderField: "Content-Type")
            request.setValue(EnvironmentConfig.supabaseAnonKey, forHTTPHeaderField: "apikey")
            request.setValue("bearer \(session.accessToken)", forHTTPHeaderField: "Authorization")
            request.setValue("return=representation", forHTTPHeaderField: "Prefer")
            request.httpBody = userData

            print("üåê Making raw HTTP request...")
            print("   - URL: \(url)")
            print("   - Headers: apikey, Authorization, Content-Type, Prefer")

            do {
                let (data, httpResponse) = try await URLSession.shared.data(for: request)
                let statusCode = (httpResponse as? HTTPURLResponse)?.statusCode ?? 0

                print("‚úÖ HTTP Response received!")
                print("   - Status Code: \(statusCode)")
                print("   - Response size: \(data.count) bytes")

                if let responseText = String(data: data, encoding: .utf8) {
                    print("   - Response body: \(responseText)")
                }

                if statusCode >= 400 {
                    print("‚ùå HTTP Error! Status: \(statusCode)")

                    if let responseText = String(data: data, encoding: .utf8) {
                        print("   - Error details: \(responseText)")

                        // Check for duplicate username (PostgreSQL error code 23505)
                        if responseText.contains("23505") ||
                           (responseText.contains("username") && responseText.contains("unique")) {
                            print("‚ùå Detected duplicate username constraint violation")
                            throw NSError(domain: "SupabaseDataService", code: 409, userInfo: [
                                NSLocalizedDescriptionKey: "This username is already taken. Please choose another one."
                            ])
                        }
                    }

                    print("‚ùå Throwing generic invalidData error")
                    throw DataServiceError.invalidData
                }
            } catch let error as NSError {
                print("‚ùå INSERT failed with error:")
                print("   - Error: \(error)")
                print("   - Domain: \(error.domain)")
                print("   - Code: \(error.code)")
                print("   - UserInfo: \(error.userInfo)")

                // Check if it's an HTTP error with response data
                if let httpResponse = error.userInfo["HTTPURLResponse"] as? HTTPURLResponse {
                    print("   - HTTP Status: \(httpResponse.statusCode)")
                }

                if let errorData = error.userInfo["ErrorResponseData"] as? Data,
                   let errorText = String(data: errorData, encoding: .utf8) {
                    print("   - Error response body: \(errorText)")
                }

                // Re-throw to stop execution - the INSERT actually failed
                throw error
            }

            // Small delay to ensure database consistency
            try await Task.sleep(nanoseconds: 500_000_000) // 0.5 seconds

            // Now fetch the user we just created (by username, which is unique)
            print("üîç Fetching created user by username: \(user.username)")
            let fetchResponse = try await supabase
                .from("users")
                .select()
                .eq("username", value: user.username)
                .single()
                .execute()

            if let jsonString = String(data: fetchResponse.data, encoding: .utf8) {
                print("üì• Fetched user data: \(jsonString)")
            }

            let decoder = JSONDecoder()
            decoder.dateDecodingStrategy = .iso8601

            let createdUser = try decoder.decode(User.self, from: fetchResponse.data)
            print("‚úÖ User created successfully: \(createdUser.username)")
            return createdUser
        } catch let error as NSError {
            print("‚ùå Supabase insert error: \(error)")
            print("‚ùå Error domain: \(error.domain)")
            print("‚ùå Error code: \(error.code)")
            print("‚ùå Error userInfo: \(error.userInfo)")

            // Try to get more details from the underlying error
            if let underlyingError = error.userInfo[NSUnderlyingErrorKey] as? Error {
                print("‚ùå Underlying error: \(underlyingError)")
            }

            throw error
        } catch {
            print("‚ùå Supabase insert error (non-NSError): \(error)")
            throw error
        }
    }

    func updateUser(_ user: User) async throws -> User {
        // Only encode updatable fields (not id, auth_user_id, created_at)
        let updateData: [String: Any] = [
            "username": user.username,
            "avatar_emoji": user.avatarEmoji,
            "starting_balance": user.startingBalance,
            "highest_net_worth": user.highestNetWorth,
            "current_streak": user.currentStreak,
            "best_streak": user.bestStreak,
            "updated_at": ISO8601DateFormatter().string(from: Date())
        ]

        let jsonData = try JSONSerialization.data(withJSONObject: updateData)

        // Use raw HTTP PATCH (same workaround as portfolio/holdings)
        let session = try await supabase.auth.session
        let supabaseURL = EnvironmentConfig.supabaseURL
        let url = URL(string: "\(supabaseURL)/rest/v1/users?id=eq.\(user.id.uuidString.lowercased())")!

        var request = URLRequest(url: url)
        request.httpMethod = "PATCH"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.setValue(EnvironmentConfig.supabaseAnonKey, forHTTPHeaderField: "apikey")
        request.setValue("bearer \(session.accessToken)", forHTTPHeaderField: "Authorization")
        request.setValue("return=representation", forHTTPHeaderField: "Prefer")
        request.httpBody = jsonData

        let (data, httpResponse) = try await URLSession.shared.data(for: request)
        let statusCode = (httpResponse as? HTTPURLResponse)?.statusCode ?? 0

        if statusCode >= 400 {
            if let responseText = String(data: data, encoding: .utf8) {
                print("‚ùå User update error: \(responseText)")
            }
            throw DataServiceError.invalidData
        }

        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .iso8601

        let users = try decoder.decode([User].self, from: data)
        guard let updatedUser = users.first else {
            throw DataServiceError.invalidData
        }

        return updatedUser
    }

    // MARK: - Portfolio Operations

    func fetchPortfolio(userId: UUID) async throws -> Portfolio {
        // Check if offline
        if !NetworkMonitor.shared.isConnected {
            print("   üìµ Offline - cannot fetch portfolio from database")
            throw DataServiceError.networkError(NSError(domain: "NetworkMonitor", code: -1009, userInfo: [
                NSLocalizedDescriptionKey: "No internet connection. Please check your network settings."
            ]))
        }

        let response = try await supabase
            .from("portfolios")
            .select()
            .eq("user_id", value: userId.uuidString)
            .single()
            .execute()

        let decoder = JSONDecoder()
        // Don't use convertFromSnakeCase - Portfolio model has explicit CodingKeys
        decoder.dateDecodingStrategy = .iso8601

        var portfolio = try decoder.decode(Portfolio.self, from: response.data)

        // Fetch associated holdings and transactions
        portfolio.holdings = try await fetchHoldings(portfolioId: portfolio.id)
        portfolio.transactions = try await fetchTransactions(portfolioId: portfolio.id, limit: 100)

        return portfolio
    }

    func updatePortfolio(_ portfolio: Portfolio) async throws -> Portfolio {
        // Only encode the portfolio data, not holdings/transactions
        let updateData: [String: Any] = [
            "cash_balance": portfolio.cashBalance,
            "updated_at": ISO8601DateFormatter().string(from: Date())
        ]

        let jsonData = try JSONSerialization.data(withJSONObject: updateData)

        // Use raw HTTP for UPDATE (same workaround as holdings)
        let session = try await supabase.auth.session
        let supabaseURL = EnvironmentConfig.supabaseURL
        let url = URL(string: "\(supabaseURL)/rest/v1/portfolios?id=eq.\(portfolio.id.uuidString.lowercased())")!

        var request = URLRequest(url: url)
        request.httpMethod = "PATCH"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.setValue(EnvironmentConfig.supabaseAnonKey, forHTTPHeaderField: "apikey")
        request.setValue("bearer \(session.accessToken)", forHTTPHeaderField: "Authorization")
        request.setValue("return=representation", forHTTPHeaderField: "Prefer")
        request.httpBody = jsonData

        let (data, httpResponse) = try await URLSession.shared.data(for: request)
        let statusCode = (httpResponse as? HTTPURLResponse)?.statusCode ?? 0

        if statusCode >= 400 {
            if let responseText = String(data: data, encoding: .utf8) {
                print("‚ùå Portfolio update error: \(responseText)")
            }
            throw DataServiceError.invalidData
        }

        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .iso8601

        let portfolios = try decoder.decode([Portfolio].self, from: data)
        guard var updatedPortfolio = portfolios.first else {
            throw DataServiceError.invalidData
        }

        updatedPortfolio.holdings = portfolio.holdings
        updatedPortfolio.transactions = portfolio.transactions

        return updatedPortfolio
    }

    func createPortfolio(userId: UUID, startingBalance: Double) async throws -> Portfolio {
        print("üîç Creating portfolio for user: \(userId)")

        let newPortfolio = Portfolio(userId: userId, startingBalance: startingBalance)

        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .iso8601

        // Encode as array (Supabase expects array)
        let portfolioData = try encoder.encode([newPortfolio])

        // Use raw HTTP request (same workaround as createUser)
        let session = try await supabase.auth.session
        let supabaseURL = EnvironmentConfig.supabaseURL
        let url = URL(string: "\(supabaseURL)/rest/v1/portfolios")!

        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.setValue(EnvironmentConfig.supabaseAnonKey, forHTTPHeaderField: "apikey")
        request.setValue("bearer \(session.accessToken)", forHTTPHeaderField: "Authorization")
        request.setValue("return=representation", forHTTPHeaderField: "Prefer")
        request.httpBody = portfolioData

        let (data, httpResponse) = try await URLSession.shared.data(for: request)
        let statusCode = (httpResponse as? HTTPURLResponse)?.statusCode ?? 0

        print("‚úÖ Portfolio HTTP Response: Status \(statusCode)")

        if let responseText = String(data: data, encoding: .utf8) {
            print("   - Response: \(responseText)")
        }

        if statusCode >= 400 {
            print("‚ùå HTTP Error Status: \(statusCode)")

            if let responseText = String(data: data, encoding: .utf8) {
                print("‚ùå Error response: \(responseText)")

                // Check for duplicate username (unique constraint violation)
                if responseText.contains("username") && (responseText.contains("unique") || responseText.contains("duplicate")) {
                    print("‚ùå Detected duplicate username error")
                    throw NSError(domain: "SupabaseDataService", code: 409, userInfo: [
                        NSLocalizedDescriptionKey: "This username is already taken. Please choose another one."
                    ])
                }
            }

            print("‚ùå Throwing generic invalidData error")
            throw DataServiceError.invalidData
        }

        // Decode response (should be array)
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .iso8601

        let portfolios = try decoder.decode([Portfolio].self, from: data)
        guard var createdPortfolio = portfolios.first else {
            throw DataServiceError.portfolioNotFound
        }

        // Initialize empty arrays
        createdPortfolio.holdings = []
        createdPortfolio.transactions = []

        print("‚úÖ Portfolio created successfully")
        return createdPortfolio
    }

    // MARK: - Holdings Operations

    func fetchHoldings(portfolioId: UUID) async throws -> [Holding] {
        // Check if offline
        if !NetworkMonitor.shared.isConnected {
            print("   üìµ Offline - cannot fetch holdings from database")
            throw DataServiceError.networkError(NSError(domain: "NetworkMonitor", code: -1009, userInfo: [
                NSLocalizedDescriptionKey: "No internet connection. Please check your network settings."
            ]))
        }

        let response = try await supabase
            .from("holdings")
            .select()
            .eq("portfolio_id", value: portfolioId.uuidString)
            .order("first_purchase_date", ascending: false)
            .execute()

        let decoder = JSONDecoder()
        // Don't use convertFromSnakeCase - Models have explicit CodingKeys
        decoder.dateDecodingStrategy = .iso8601

        let holdings = try decoder.decode([Holding].self, from: response.data)
        return holdings
    }

    func upsertHolding(_ holding: Holding) async throws -> Holding {
        // Check if holding exists (use lowercased UUID for PostgreSQL)
        print("üîç Checking for existing holding: portfolio=\(holding.portfolioId.uuidString.lowercased()), coin=\(holding.coinId)")
        let existingResponse = try? await supabase
            .from("holdings")
            .select()
            .eq("portfolio_id", value: holding.portfolioId.uuidString.lowercased())
            .eq("coin_id", value: holding.coinId)
            .execute()

        let decoder = JSONDecoder()
        // Don't use convertFromSnakeCase - Models have explicit CodingKeys
        decoder.dateDecodingStrategy = .iso8601

        if let responseData = existingResponse?.data,
           let jsonString = String(data: responseData, encoding: .utf8),
           jsonString != "[]" {
            // Holding exists - try to UPDATE it
            print("   ‚úÖ Found existing holding, updating...")

            // Create update payload with only the fields we want to update
            // Don't include id, created_at, first_purchase_date - these shouldn't change
            let updateData: [String: Any] = [
                "quantity": holding.quantity,
                "average_buy_price": holding.averageBuyPrice,
                "coin_name": holding.coinName,
                "coin_symbol": holding.coinSymbol,
                "coin_image": holding.coinImage?.absoluteString ?? "",
                "updated_at": ISO8601DateFormatter().string(from: Date())
            ]

            let updateJSON = try JSONSerialization.data(withJSONObject: updateData)

            if let jsonString = String(data: updateJSON, encoding: .utf8) {
                print("   üì§ Update data: \(jsonString)")
            }

            // Use raw HTTP for UPDATE (same workaround as INSERT)
            let session = try await supabase.auth.session
            let supabaseURL = EnvironmentConfig.supabaseURL
            let url = URL(string: "\(supabaseURL)/rest/v1/holdings?portfolio_id=eq.\(holding.portfolioId.uuidString.lowercased())&coin_id=eq.\(holding.coinId)")!

            var request = URLRequest(url: url)
            request.httpMethod = "PATCH"
            request.setValue("application/json", forHTTPHeaderField: "Content-Type")
            request.setValue(EnvironmentConfig.supabaseAnonKey, forHTTPHeaderField: "apikey")
            request.setValue("bearer \(session.accessToken)", forHTTPHeaderField: "Authorization")
            request.setValue("return=representation", forHTTPHeaderField: "Prefer")
            request.httpBody = updateJSON

            let (data, httpResponse) = try await URLSession.shared.data(for: request)
            let statusCode = (httpResponse as? HTTPURLResponse)?.statusCode ?? 0

            if let jsonString = String(data: data, encoding: .utf8) {
                print("   üì• Update response (status \(statusCode)): \(jsonString)")
            }

            if statusCode == 200 || statusCode == 204 {
                // Parse response array
                let holdings = try decoder.decode([Holding].self, from: data)
                print("   ‚úÖ Decoded \(holdings.count) holdings")

                if let upsertedHolding = holdings.first {
                    return upsertedHolding  // SUCCESS
                } else {
                    print("   ‚ö†Ô∏è UPDATE returned 0 rows, will try INSERT")
                }
            } else if statusCode >= 400 {
                print("   ‚ùå UPDATE failed with HTTP \(statusCode), will try INSERT")
            }
        }

        // INSERT new holding (either because it doesn't exist, or UPDATE failed)
        print("   ‚ÑπÔ∏è Creating new holding...")
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .iso8601
        let holdingArray = try encoder.encode([holding])

        let session = try await supabase.auth.session
        let supabaseURL = EnvironmentConfig.supabaseURL
        let url = URL(string: "\(supabaseURL)/rest/v1/holdings")!

        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.setValue(EnvironmentConfig.supabaseAnonKey, forHTTPHeaderField: "apikey")
        request.setValue("bearer \(session.accessToken)", forHTTPHeaderField: "Authorization")
        request.setValue("return=representation", forHTTPHeaderField: "Prefer")
        request.httpBody = holdingArray

        let (data, httpResponse) = try await URLSession.shared.data(for: request)
        let statusCode = (httpResponse as? HTTPURLResponse)?.statusCode ?? 0

        if statusCode >= 400 {
            if let responseText = String(data: data, encoding: .utf8) {
                print("‚ùå Holding insert error: \(responseText)")
            }
            throw DataServiceError.invalidData
        }

        let holdings = try decoder.decode([Holding].self, from: data)
        guard let upsertedHolding = holdings.first else {
            throw DataServiceError.invalidData
        }

        return upsertedHolding
    }

    func deleteHolding(holdingId: UUID) async throws {
        _ = try await supabase
            .from("holdings")
            .delete()
            .eq("id", value: holdingId.uuidString)
            .execute()
    }

    func deleteAllHoldings(portfolioId: UUID) async throws {
        print("üóëÔ∏è SupabaseDataService: Deleting all holdings for portfolio \(portfolioId)")
        _ = try await supabase
            .from("holdings")
            .delete()
            .eq("portfolio_id", value: portfolioId.uuidString)
            .execute()
        print("   ‚úÖ All holdings deleted")
    }

    // MARK: - Transaction Operations

    func fetchTransactions(portfolioId: UUID, limit: Int = 100) async throws -> [Transaction] {
        // Check if offline
        if !NetworkMonitor.shared.isConnected {
            print("   üìµ Offline - cannot fetch transactions from database")
            throw DataServiceError.networkError(NSError(domain: "NetworkMonitor", code: -1009, userInfo: [
                NSLocalizedDescriptionKey: "No internet connection. Please check your network settings."
            ]))
        }

        let response = try await supabase
            .from("transactions")
            .select()
            .eq("portfolio_id", value: portfolioId.uuidString)
            .order("timestamp", ascending: false)
            .limit(limit)
            .execute()

        let decoder = JSONDecoder()
        // Don't use convertFromSnakeCase - Models have explicit CodingKeys
        decoder.dateDecodingStrategy = .iso8601

        let transactions = try decoder.decode([Transaction].self, from: response.data)
        return transactions
    }

    func createTransaction(_ transaction: Transaction) async throws -> Transaction {
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .iso8601

        // Encode as array (Supabase expects array)
        let transactionData = try encoder.encode([transaction])

        // Debug: Print transaction details
        if let jsonString = String(data: transactionData, encoding: .utf8) {
            print("üì§ Creating transaction: \(jsonString)")
        }

        // Use raw HTTP request (same workaround as createUser/createPortfolio)
        let session = try await supabase.auth.session
        print("üîç Auth user ID: \(session.user.id)")

        // Debug: Verify portfolio ownership chain
        do {
            // 1. Check portfolio exists
            let portfolioCheck = try await supabase
                .from("portfolios")
                .select("id, user_id")
                .eq("id", value: transaction.portfolioId.uuidString.lowercased())
                .execute()

            if let jsonString = String(data: portfolioCheck.data, encoding: .utf8) {
                print("üîç Portfolio query result: \(jsonString)")
            }

            // 2. Check user exists
            let userCheck = try await supabase
                .from("users")
                .select("id, auth_user_id, username")
                .eq("auth_user_id", value: session.user.id.uuidString.lowercased())
                .execute()

            if let jsonString = String(data: userCheck.data, encoding: .utf8) {
                print("üîç User query result: \(jsonString)")
            }
        } catch {
            print("‚ùå Debug queries failed: \(error)")
        }

        let supabaseURL = EnvironmentConfig.supabaseURL
        let url = URL(string: "\(supabaseURL)/rest/v1/transactions")!

        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.setValue(EnvironmentConfig.supabaseAnonKey, forHTTPHeaderField: "apikey")
        request.setValue("bearer \(session.accessToken)", forHTTPHeaderField: "Authorization")
        request.setValue("return=representation", forHTTPHeaderField: "Prefer")
        request.httpBody = transactionData

        let (data, httpResponse) = try await URLSession.shared.data(for: request)
        let statusCode = (httpResponse as? HTTPURLResponse)?.statusCode ?? 0

        if statusCode >= 400 {
            if let responseText = String(data: data, encoding: .utf8) {
                print("‚ùå Transaction insert error: \(responseText)")
            }
            throw DataServiceError.invalidData
        }

        // Decode response (should be array)
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .iso8601

        let transactions = try decoder.decode([Transaction].self, from: data)
        guard let createdTransaction = transactions.first else {
            throw DataServiceError.invalidData
        }

        return createdTransaction
    }

    func deleteAllTransactions(portfolioId: UUID) async throws {
        print("üóëÔ∏è SupabaseDataService: Deleting all transactions for portfolio \(portfolioId)")
        _ = try await supabase
            .from("transactions")
            .delete()
            .eq("portfolio_id", value: portfolioId.uuidString)
            .execute()
        print("   ‚úÖ All transactions deleted")
    }

    // MARK: - Leaderboard Operations

    func fetchLeaderboard(limit: Int) async throws -> [LeaderboardEntry] {
        print("üèÜ Fetching leaderboard (limit: \(limit))...")

        // Check if offline
        if !NetworkMonitor.shared.isConnected {
            print("   üìµ Offline - cannot fetch leaderboard from database")
            throw DataServiceError.networkError(NSError(domain: "NetworkMonitor", code: -1009, userInfo: [
                NSLocalizedDescriptionKey: "No internet connection. Leaderboard requires connectivity."
            ]))
        }

        // Call the PostgreSQL function
        let response = try await supabase
            .rpc("get_leaderboard", params: ["limit_count": limit])
            .execute()

        if let jsonString = String(data: response.data, encoding: .utf8) {
            print("üì• Leaderboard response: \(jsonString)")
        }

        // Decode the response
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase

        // The RPC function returns an array of objects with: user_id, username, avatar_emoji, net_worth, gain_percentage, rank
        struct LeaderboardRow: Decodable {
            let userId: UUID
            let username: String
            let avatarEmoji: String
            let netWorth: Double
            let gainPercentage: Double
            let rank: Int
        }

        let rows = try decoder.decode([LeaderboardRow].self, from: response.data)

        // Convert to LeaderboardEntry objects
        let entries = rows.map { row in
            LeaderboardEntry(
                rank: row.rank,
                username: row.username,
                avatarEmoji: row.avatarEmoji,
                netWorth: row.netWorth,
                percentageGain: row.gainPercentage,
                isCurrentUser: false  // Will be set by caller
            )
        }

        print("‚úÖ Loaded \(entries.count) leaderboard entries")
        return entries
    }

    func fetchUserRank(userId: UUID) async throws -> LeaderboardEntry? {
        print("üèÜ Fetching rank for user: \(userId)...")

        // Check if offline
        if !NetworkMonitor.shared.isConnected {
            print("   üìµ Offline - cannot fetch user rank from database")
            throw DataServiceError.networkError(NSError(domain: "NetworkMonitor", code: -1009, userInfo: [
                NSLocalizedDescriptionKey: "No internet connection. Rank requires connectivity."
            ]))
        }

        // Call the PostgreSQL function
        let response = try await supabase
            .rpc("get_user_rank", params: ["input_user_id": userId.uuidString.lowercased()])
            .execute()

        if let jsonString = String(data: response.data, encoding: .utf8) {
            print("üì• User rank response: \(jsonString)")
        }

        // Decode the response
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase

        struct LeaderboardRow: Decodable {
            let userId: UUID
            let username: String
            let avatarEmoji: String
            let netWorth: Double
            let gainPercentage: Double
            let rank: Int
        }

        let rows = try decoder.decode([LeaderboardRow].self, from: response.data)

        guard let row = rows.first else {
            print("‚ö†Ô∏è No rank found for user")
            return nil
        }

        let entry = LeaderboardEntry(
            rank: row.rank,
            username: row.username,
            avatarEmoji: row.avatarEmoji,
            netWorth: row.netWorth,
            percentageGain: row.gainPercentage,
            isCurrentUser: true
        )

        print("‚úÖ User rank: #\(entry.rank)")
        return entry
    }
}
