//
//  SupabaseDataService.swift
//  CoinFlip
//
//  Created on Sprint 11, Task 11.3
//  Real implementation of DataServiceProtocol using Supabase
//

import Foundation
import Supabase

/// Supabase data service for production
///
/// This service implements DataServiceProtocol using Supabase as the backend.
/// All operations are async and interact with the PostgreSQL database.
@MainActor
class SupabaseDataService: DataServiceProtocol {

    // MARK: - Properties

    private let supabase: SupabaseClient

    // MARK: - Initialization

    init() {
        self.supabase = SupabaseService.shared.client
    }

    init(supabase: SupabaseClient) {
        self.supabase = supabase
    }

    // MARK: - User Operations

    func fetchUser() async throws -> User? {
        // Get current auth user
        guard let authUser = try? await supabase.auth.session.user else {
            throw DataServiceError.notAuthenticated
        }

        // Fetch user from database
        let response = try await supabase
            .from("users")
            .select()
            .eq("auth_user_id", value: authUser.id.uuidString)
            .single()
            .execute()

        let decoder = JSONDecoder()
        // Don't use convertFromSnakeCase - User model has explicit CodingKeys
        decoder.dateDecodingStrategy = .iso8601

        let user = try decoder.decode(User.self, from: response.data)
        return user
    }

    func createUser(_ user: User) async throws -> User {
        // Create a dictionary with only the fields we should send
        // Don't send id, created_at, updated_at - these are auto-generated by the database
        var userDict: [String: Any] = [
            "username": user.username,
            "avatar_emoji": user.avatarEmoji,
            "starting_balance": user.startingBalance,
            "highest_net_worth": user.highestNetWorth,
            "current_streak": user.currentStreak,
            "best_streak": user.bestStreak
        ]

        // Add auth_user_id if present (use lowercase for PostgreSQL compatibility)
        if let authUserId = user.authUserId {
            userDict["auth_user_id"] = authUserId.uuidString.lowercased()
        }

        // Supabase insert expects an array of objects, not a single object
        let userArray = [userDict]
        let userData = try JSONSerialization.data(withJSONObject: userArray)

        // Debug: Print what we're sending
        if let jsonString = String(data: userData, encoding: .utf8) {
            print("üì§ Sending user data to Supabase (as array): \(jsonString)")
        }

        do {
            // First, verify we have an authenticated session
            print("üîç Checking auth session...")
            do {
                let session = try await supabase.auth.session
                print("‚úÖ Auth session found:")
                print("   - User ID: \(session.user.id)")
                print("   - Access token exists: \(session.accessToken.count > 0)")
                print("   - Token type: \(session.tokenType)")
            } catch {
                print("‚ùå No auth session! Error: \(error)")
                throw DataServiceError.notAuthenticated
            }

            print("üîç Attempting INSERT to Supabase...")
            print("üìä Request details:")
            print("   - Table: users")
            print("   - Method: INSERT (HTTP POST)")
            print("   - JSON size: \(userData.count) bytes")

            // Try raw HTTP request to see actual response
            let session = try await supabase.auth.session
            let supabaseURL = EnvironmentConfig.supabaseURL
            let url = URL(string: "\(supabaseURL)/rest/v1/users")!

            var request = URLRequest(url: url)
            request.httpMethod = "POST"
            request.setValue("application/json", forHTTPHeaderField: "Content-Type")
            request.setValue(EnvironmentConfig.supabaseAnonKey, forHTTPHeaderField: "apikey")
            request.setValue("bearer \(session.accessToken)", forHTTPHeaderField: "Authorization")
            request.setValue("return=representation", forHTTPHeaderField: "Prefer")
            request.httpBody = userData

            print("üåê Making raw HTTP request...")
            print("   - URL: \(url)")
            print("   - Headers: apikey, Authorization, Content-Type, Prefer")

            do {
                let (data, httpResponse) = try await URLSession.shared.data(for: request)
                let statusCode = (httpResponse as? HTTPURLResponse)?.statusCode ?? 0

                print("‚úÖ HTTP Response received!")
                print("   - Status Code: \(statusCode)")
                print("   - Response size: \(data.count) bytes")

                if let responseText = String(data: data, encoding: .utf8) {
                    print("   - Response body: \(responseText)")
                }

                if statusCode >= 400 {
                    print("‚ùå HTTP Error! Status: \(statusCode)")

                    if let responseText = String(data: data, encoding: .utf8) {
                        print("   - Error details: \(responseText)")

                        // Check for duplicate username (PostgreSQL error code 23505)
                        if responseText.contains("23505") ||
                           (responseText.contains("username") && responseText.contains("unique")) {
                            print("‚ùå Detected duplicate username constraint violation")
                            throw NSError(domain: "SupabaseDataService", code: 409, userInfo: [
                                NSLocalizedDescriptionKey: "This username is already taken. Please choose another one."
                            ])
                        }
                    }

                    print("‚ùå Throwing generic invalidData error")
                    throw DataServiceError.invalidData
                }
            } catch let error as NSError {
                print("‚ùå INSERT failed with error:")
                print("   - Error: \(error)")
                print("   - Domain: \(error.domain)")
                print("   - Code: \(error.code)")
                print("   - UserInfo: \(error.userInfo)")

                // Check if it's an HTTP error with response data
                if let httpResponse = error.userInfo["HTTPURLResponse"] as? HTTPURLResponse {
                    print("   - HTTP Status: \(httpResponse.statusCode)")
                }

                if let errorData = error.userInfo["ErrorResponseData"] as? Data,
                   let errorText = String(data: errorData, encoding: .utf8) {
                    print("   - Error response body: \(errorText)")
                }

                // Re-throw to stop execution - the INSERT actually failed
                throw error
            }

            // Small delay to ensure database consistency
            try await Task.sleep(nanoseconds: 500_000_000) // 0.5 seconds

            // Now fetch the user we just created (by username, which is unique)
            print("üîç Fetching created user by username: \(user.username)")
            let fetchResponse = try await supabase
                .from("users")
                .select()
                .eq("username", value: user.username)
                .single()
                .execute()

            if let jsonString = String(data: fetchResponse.data, encoding: .utf8) {
                print("üì• Fetched user data: \(jsonString)")
            }

            let decoder = JSONDecoder()
            decoder.dateDecodingStrategy = .iso8601

            let createdUser = try decoder.decode(User.self, from: fetchResponse.data)
            print("‚úÖ User created successfully: \(createdUser.username)")
            return createdUser
        } catch let error as NSError {
            print("‚ùå Supabase insert error: \(error)")
            print("‚ùå Error domain: \(error.domain)")
            print("‚ùå Error code: \(error.code)")
            print("‚ùå Error userInfo: \(error.userInfo)")

            // Try to get more details from the underlying error
            if let underlyingError = error.userInfo[NSUnderlyingErrorKey] as? Error {
                print("‚ùå Underlying error: \(underlyingError)")
            }

            throw error
        } catch {
            print("‚ùå Supabase insert error (non-NSError): \(error)")
            throw error
        }
    }

    func updateUser(_ user: User) async throws -> User {
        let encoder = JSONEncoder()
        // Don't use convertToSnakeCase - User model has explicit CodingKeys
        encoder.dateEncodingStrategy = .iso8601

        let userData = try encoder.encode(user)

        let response = try await supabase
            .from("users")
            .update(userData)
            .eq("id", value: user.id.uuidString)
            .select()
            .single()
            .execute()

        let decoder = JSONDecoder()
        // Don't use convertFromSnakeCase - User model has explicit CodingKeys
        decoder.dateDecodingStrategy = .iso8601

        let updatedUser = try decoder.decode(User.self, from: response.data)
        return updatedUser
    }

    // MARK: - Portfolio Operations

    func fetchPortfolio(userId: UUID) async throws -> Portfolio {
        let response = try await supabase
            .from("portfolios")
            .select()
            .eq("user_id", value: userId.uuidString)
            .single()
            .execute()

        let decoder = JSONDecoder()
        // Don't use convertFromSnakeCase - Portfolio model has explicit CodingKeys
        decoder.dateDecodingStrategy = .iso8601

        var portfolio = try decoder.decode(Portfolio.self, from: response.data)

        // Fetch associated holdings and transactions
        portfolio.holdings = try await fetchHoldings(portfolioId: portfolio.id)
        portfolio.transactions = try await fetchTransactions(portfolioId: portfolio.id, limit: 100)

        return portfolio
    }

    func updatePortfolio(_ portfolio: Portfolio) async throws -> Portfolio {
        let encoder = JSONEncoder()
        // Don't use convertToSnakeCase - Models have explicit CodingKeys
        encoder.dateEncodingStrategy = .iso8601

        // Only encode the portfolio data, not holdings/transactions
        let updateData: [String: Any] = [
            "cash_balance": portfolio.cashBalance,
            "updated_at": ISO8601DateFormatter().string(from: Date())
        ]

        let jsonData = try JSONSerialization.data(withJSONObject: updateData)

        let response = try await supabase
            .from("portfolios")
            .update(jsonData)
            .eq("id", value: portfolio.id.uuidString)
            .select()
            .single()
            .execute()

        let decoder = JSONDecoder()
        // Don't use convertFromSnakeCase - Models have explicit CodingKeys
        decoder.dateDecodingStrategy = .iso8601

        var updatedPortfolio = try decoder.decode(Portfolio.self, from: response.data)
        updatedPortfolio.holdings = portfolio.holdings
        updatedPortfolio.transactions = portfolio.transactions

        return updatedPortfolio
    }

    func createPortfolio(userId: UUID, startingBalance: Double) async throws -> Portfolio {
        print("üîç Creating portfolio for user: \(userId)")

        let newPortfolio = Portfolio(userId: userId, startingBalance: startingBalance)

        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .iso8601

        // Encode as array (Supabase expects array)
        let portfolioData = try encoder.encode([newPortfolio])

        // Use raw HTTP request (same workaround as createUser)
        let session = try await supabase.auth.session
        let supabaseURL = EnvironmentConfig.supabaseURL
        let url = URL(string: "\(supabaseURL)/rest/v1/portfolios")!

        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.setValue(EnvironmentConfig.supabaseAnonKey, forHTTPHeaderField: "apikey")
        request.setValue("bearer \(session.accessToken)", forHTTPHeaderField: "Authorization")
        request.setValue("return=representation", forHTTPHeaderField: "Prefer")
        request.httpBody = portfolioData

        let (data, httpResponse) = try await URLSession.shared.data(for: request)
        let statusCode = (httpResponse as? HTTPURLResponse)?.statusCode ?? 0

        print("‚úÖ Portfolio HTTP Response: Status \(statusCode)")

        if let responseText = String(data: data, encoding: .utf8) {
            print("   - Response: \(responseText)")
        }

        if statusCode >= 400 {
            print("‚ùå HTTP Error Status: \(statusCode)")

            if let responseText = String(data: data, encoding: .utf8) {
                print("‚ùå Error response: \(responseText)")

                // Check for duplicate username (unique constraint violation)
                if responseText.contains("username") && (responseText.contains("unique") || responseText.contains("duplicate")) {
                    print("‚ùå Detected duplicate username error")
                    throw NSError(domain: "SupabaseDataService", code: 409, userInfo: [
                        NSLocalizedDescriptionKey: "This username is already taken. Please choose another one."
                    ])
                }
            }

            print("‚ùå Throwing generic invalidData error")
            throw DataServiceError.invalidData
        }

        // Decode response (should be array)
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .iso8601

        let portfolios = try decoder.decode([Portfolio].self, from: data)
        guard var createdPortfolio = portfolios.first else {
            throw DataServiceError.portfolioNotFound
        }

        // Initialize empty arrays
        createdPortfolio.holdings = []
        createdPortfolio.transactions = []

        print("‚úÖ Portfolio created successfully")
        return createdPortfolio
    }

    // MARK: - Holdings Operations

    func fetchHoldings(portfolioId: UUID) async throws -> [Holding] {
        let response = try await supabase
            .from("holdings")
            .select()
            .eq("portfolio_id", value: portfolioId.uuidString)
            .order("first_purchase_date", ascending: false)
            .execute()

        let decoder = JSONDecoder()
        // Don't use convertFromSnakeCase - Models have explicit CodingKeys
        decoder.dateDecodingStrategy = .iso8601

        let holdings = try decoder.decode([Holding].self, from: response.data)
        return holdings
    }

    func upsertHolding(_ holding: Holding) async throws -> Holding {
        let encoder = JSONEncoder()
        // Don't use convertToSnakeCase - Models have explicit CodingKeys
        encoder.dateEncodingStrategy = .iso8601

        let holdingData = try encoder.encode(holding)

        // Check if holding exists
        let existingResponse = try? await supabase
            .from("holdings")
            .select()
            .eq("portfolio_id", value: holding.portfolioId.uuidString)
            .eq("coin_id", value: holding.coinId)
            .single()
            .execute()

        let decoder = JSONDecoder()
        // Don't use convertFromSnakeCase - Models have explicit CodingKeys
        decoder.dateDecodingStrategy = .iso8601

        if existingResponse != nil {
            // Update existing holding
            let updateResponse = try await supabase
                .from("holdings")
                .update(holdingData)
                .eq("portfolio_id", value: holding.portfolioId.uuidString)
                .eq("coin_id", value: holding.coinId)
                .select()
                .single()
                .execute()

            let upsertedHolding = try decoder.decode(Holding.self, from: updateResponse.data)
            return upsertedHolding
        } else {
            // Insert new holding
            let insertResponse = try await supabase
                .from("holdings")
                .insert(holdingData)
                .select()
                .single()
                .execute()

            let upsertedHolding = try decoder.decode(Holding.self, from: insertResponse.data)
            return upsertedHolding
        }
    }

    func deleteHolding(holdingId: UUID) async throws {
        _ = try await supabase
            .from("holdings")
            .delete()
            .eq("id", value: holdingId.uuidString)
            .execute()
    }

    // MARK: - Transaction Operations

    func fetchTransactions(portfolioId: UUID, limit: Int = 100) async throws -> [Transaction] {
        let response = try await supabase
            .from("transactions")
            .select()
            .eq("portfolio_id", value: portfolioId.uuidString)
            .order("timestamp", ascending: false)
            .limit(limit)
            .execute()

        let decoder = JSONDecoder()
        // Don't use convertFromSnakeCase - Models have explicit CodingKeys
        decoder.dateDecodingStrategy = .iso8601

        let transactions = try decoder.decode([Transaction].self, from: response.data)
        return transactions
    }

    func createTransaction(_ transaction: Transaction) async throws -> Transaction {
        let encoder = JSONEncoder()
        // Don't use convertToSnakeCase - Models have explicit CodingKeys
        encoder.dateEncodingStrategy = .iso8601

        let transactionData = try encoder.encode(transaction)

        let response = try await supabase
            .from("transactions")
            .insert(transactionData)
            .select()
            .single()
            .execute()

        let decoder = JSONDecoder()
        // Don't use convertFromSnakeCase - Models have explicit CodingKeys
        decoder.dateDecodingStrategy = .iso8601

        let createdTransaction = try decoder.decode(Transaction.self, from: response.data)
        return createdTransaction
    }

    // MARK: - Leaderboard Operations

    func fetchLeaderboard(limit: Int) async throws -> [LeaderboardEntry] {
        // TODO: Implement with PostgreSQL function in Sprint 16
        // For now, return empty array
        print("‚ö†Ô∏è SupabaseDataService: fetchLeaderboard not yet implemented")
        return []
    }

    func fetchUserRank(userId: UUID) async throws -> LeaderboardEntry? {
        // TODO: Implement with PostgreSQL function in Sprint 16
        // For now, return nil
        print("‚ö†Ô∏è SupabaseDataService: fetchUserRank not yet implemented")
        return nil
    }
}
